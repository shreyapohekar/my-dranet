<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Linux Network Namespaces and Interfaces | DRANET</title>
<meta name=description content="Network namespaces create isolated network stacks, including network devices, IP addresses, routing tables, rules , … This separation is crucial for containerization.
Network namespaces also contain network devices that can live exactly on one network namespace:
physical network device can live in exactly one network namespace. When a network namespace is freed (i.e., when the last process in the namespace terminates), its physical network devices are moved back to the initial network namespace (not to the namespace of the parent of the process)."><meta property="og:url" content="https://dranet.dev/docs/concepts/linux-network-interfaces/"><meta property="og:site_name" content="DRANET"><meta property="og:title" content="Linux Network Namespaces and Interfaces"><meta property="og:description" content="Network namespaces create isolated network stacks, including network devices, IP addresses, routing tables, rules , … This separation is crucial for containerization.
Network namespaces also contain network devices that can live exactly on one network namespace:
physical network device can live in exactly one network namespace. When a network namespace is freed (i.e., when the last process in the namespace terminates), its physical network devices are moved back to the initial network namespace (not to the namespace of the parent of the process)."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-06-05T11:20:46+00:00"><meta property="article:modified_time" content="2025-06-05T11:20:46+00:00"><meta itemprop=name content="Linux Network Namespaces and Interfaces"><meta itemprop=description content="Network namespaces create isolated network stacks, including network devices, IP addresses, routing tables, rules , &mldr; This separation is crucial for containerization.
Network namespaces also contain network devices that can live exactly on one network namespace:
physical network device can live in exactly one network namespace. When a network namespace is freed (i.e., when the last process in the namespace terminates), its physical network devices are moved back to the initial network namespace (not to the namespace of the parent of the process)."><meta itemprop=datePublished content="2025-06-05T11:20:46+00:00"><meta itemprop=dateModified content="2025-06-05T11:20:46+00:00"><meta itemprop=wordCount content="1793"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Network Namespaces and Interfaces"><meta name=twitter:description content="Network namespaces create isolated network stacks, including network devices, IP addresses, routing tables, rules , &mldr; This separation is crucial for containerization.
Network namespaces also contain network devices that can live exactly on one network namespace:
physical network device can live in exactly one network namespace. When a network namespace is freed (i.e., when the last process in the namespace terminates), its physical network devices are moved back to the initial network namespace (not to the namespace of the parent of the process)."><link rel=preload href=/scss/main.min.3bb6570761fbbb25e6691001febc67f331f0953db4e4e1cfb79172c2e6a5819e.css as=style integrity="sha256-O7ZXB2H7uyXmaRAB/rxn8zHwlT205OHPt5FywualgZ4=" crossorigin=anonymous><link href=/scss/main.min.3bb6570761fbbb25e6691001febc67f331f0953db4e4e1cfb79172c2e6a5819e.css rel=stylesheet integrity="sha256-O7ZXB2H7uyXmaRAB/rxn8zHwlT205OHPt5FywualgZ4=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-YH3W884R6Z"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YH3W884R6Z")}</script></head><body class=td-page><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>DRANET</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/docs><span>Home</span></a></li><li class=nav-item><a class=nav-link href=/docs/user><span>User Guides</span></a></li><li class=nav-item><a class=nav-link href=/docs/concepts><span>Concepts</span></a></li><li class=nav-item><a class=nav-link href=/docs/contributing><span>Contributing</span></a></li></ul></div><div class="d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><form class="td-sidebar__search d-flex align-items-center"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off></div><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ms-3 fas fa-bars" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form><nav class="td-sidebar-nav collapse" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-docs-li><a href=/docs/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-docs><span>DRANET</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsquick-start-li><a href=/docs/quick-start/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsquick-start><span>Quick Start</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-docsuser-li><a href=/docs/user/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsuser><span>User Guides</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsuserkuberay-li><a href=/docs/user/kuberay/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsuserkuberay><span>Ray on GKE using DRANET</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsusernvidia-dranet-li><a href=/docs/user/nvidia-dranet/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsusernvidia-dranet><span>GKE with NVIDIA DRA and DRANET</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsusergke-tpu-performance-li><a href=/docs/user/gke-tpu-performance/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsusergke-tpu-performance><span>GKE and Cloud TPU v6e (Trillium)</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsusergke-rdma-li><a href=/docs/user/gke-rdma/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsusergke-rdma><span>GKE and GPUDirect RDMA with DRA</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsusermpi-operator-li><a href=/docs/user/mpi-operator/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsusermpi-operator><span>MPI Operator on GKE and GPUDirect RDMA</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsuserinterface-configuration-li><a href=/docs/user/interface-configuration/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsuserinterface-configuration><span>Interface Configuration</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-docsconcepts-li><a href=/docs/concepts/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docsconcepts><span>Concepts</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-docsconceptslinux-network-interfaces-li><a href=/docs/concepts/linux-network-interfaces/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-docsconceptslinux-network-interfaces><span class=td-sidebar-nav-active-item>Linux Network Namespaces and Interfaces</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsconceptsflexible-networks-li><a href=/docs/concepts/flexible-networks/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsconceptsflexible-networks><span>Making Networks Flexible</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsconceptsinterface-status-li><a href=/docs/concepts/interface-status/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsconceptsinterface-status><span>Interface Status</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsconceptshardware-efficiency-li><a href=/docs/concepts/hardware-efficiency/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsconceptshardware-efficiency><span>Hardware Efficiency</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsconceptsrdma-li><a href=/docs/concepts/rdma/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsconceptsrdma><span>RDMA</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsconceptsrdma-modes-li><a href=/docs/concepts/rdma-modes/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsconceptsrdma-modes><span>RDMA Device Handling</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsconceptshowitworks-li><a href=/docs/concepts/howitworks/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsconceptshowitworks><span>How It Works</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docsconceptsreferences-li><a href=/docs/concepts/references/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docsconceptsreferences><span>References</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-docscontributing-li><a href=/docs/contributing/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-docscontributing><span>Contributing</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docscontributingdeveloper-guide-li><a href=/docs/contributing/developer-guide/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docscontributingdeveloper-guide><span>Developer Guide</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-docscontributingcontributing-li><a href=/docs/contributing/contributing/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-docscontributingcontributing><span>Contributing</span></a></li></ul></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"><a href=https://github.com/google/dranet/tree/main/site/content/docs/concepts/linux-network-interfaces.md class="td-page-meta--view td-page-meta__view" target=_blank rel=noopener><i class="fa-solid fa-file-lines fa-fw"></i> View page source</a>
<a href=https://github.com/google/dranet/edit/main/site/content/docs/concepts/linux-network-interfaces.md class="td-page-meta--edit td-page-meta__edit" target=_blank rel=noopener><i class="fa-solid fa-pen-to-square fa-fw"></i> Edit this page</a>
<a href="https://github.com/google/dranet/new/main/site/content/docs/concepts?filename=change-me.md&amp;value=---%0Atitle%3A+%22Long+Page+Title%22%0AlinkTitle%3A+%22Short+Nav+Title%22%0Aweight%3A+100%0Adescription%3A+%3E-%0A+++++Page+description+for+heading+and+indexes.%0A---%0A%0A%23%23+Heading%0A%0AEdit+this+template+to+create+your+new+page.%0A%0A%2A+Give+it+a+good+name%2C+ending+in+%60.md%60+-+e.g.+%60getting-started.md%60%0A%2A+Edit+the+%22front+matter%22+section+at+the+top+of+the+page+%28weight+controls+how+its+ordered+amongst+other+pages+in+the+same+directory%3B+lowest+number+first%29.%0A%2A+Add+a+good+commit+message+at+the+bottom+of+the+page+%28%3C80+characters%3B+use+the+extended+description+field+for+more+detail%29.%0A%2A+Create+a+new+branch+so+you+can+preview+your+new+file+and+request+a+review+via+Pull+Request.%0A" class="td-page-meta--child td-page-meta__child" target=_blank rel=noopener><i class="fa-solid fa-pen-to-square fa-fw"></i> Create child page</a>
<a href="https://github.com/google/dranet/issues/new?title=Linux%20Network%20Namespaces%20and%20Interfaces" class="td-page-meta--issue td-page-meta__issue" target=_blank rel=noopener><i class="fa-solid fa-list-check fa-fw"></i> Create documentation issue</a></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#moving-a-network-interface-between-namespaces>Moving a network interface between namespaces</a></li><li><a href=#namespace-deletion-and-cleanup>Namespace Deletion and Cleanup</a></li><li><a href=#alternative-names>Alternative Names</a></li><li><a href=#interfaces-naming-with-systemd>Interfaces naming with systemd</a><ul><li><a href=#virtual-interfaces>Virtual interfaces</a></li><li><a href=#physical-interfaces>Physical interfaces</a></li></ul></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=/docs/>DRANET</a></li><li class=breadcrumb-item><a href=/docs/concepts/>Concepts</a></li><li class="breadcrumb-item active" aria-current=page>Linux Network Namespaces and Interfaces</li></ol></nav><div class=td-content><h1>Linux Network Namespaces and Interfaces</h1><header class=article-meta></header><p>Network namespaces create isolated network stacks, including network devices, IP addresses, routing tables, rules , &mldr;
This separation is crucial for containerization.</p><p>Network namespaces also contain network devices that <a href=https://man7.org/linux/man-pages/man7/network_namespaces.7.html>can live exactly on one network
namespace</a>:</p><blockquote><p>physical network device can live in exactly one network
namespace. When a network namespace is freed (i.e., when the last
process in the namespace terminates), its physical network devices
are moved back to the initial network namespace (not to the
namespace of the parent of the process).</p></blockquote><h2 id=moving-a-network-interface-between-namespaces>Moving a network interface between namespaces</h2><p>This is achieved using the <a href=https://github.com/torvalds/linux/blob/a7f2e10ecd8f18b83951b0bab47ddaf48f93bf47/net/core/rtnetlink.c#L2999-L3023><code>RTM_NEWLINK</code> netlink message</a>,
along with attributes specifying the target namespace.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#00f>static</span> <span style=color:#2b91af>int</span> do_setlink(<span style=color:#00f>const</span> <span style=color:#00f>struct</span> sk_buff *skb, <span style=color:#00f>struct</span> net_device *dev,
</span></span><span style=display:flex><span>		      <span style=color:#00f>struct</span> net *tgt_net, <span style=color:#00f>struct</span> ifinfomsg *ifm,
</span></span><span style=display:flex><span>		      <span style=color:#00f>struct</span> netlink_ext_ack *extack,
</span></span><span style=display:flex><span>		      <span style=color:#00f>struct</span> nlattr **tb, <span style=color:#2b91af>int</span> status)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#00f>const</span> <span style=color:#00f>struct</span> net_device_ops *ops = dev-&gt;netdev_ops;
</span></span><span style=display:flex><span>	<span style=color:#2b91af>char</span> ifname[IFNAMSIZ];
</span></span><span style=display:flex><span>	<span style=color:#2b91af>int</span> err;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	err = validate_linkmsg(dev, tb, extack);
</span></span><span style=display:flex><span>	<span style=color:#00f>if</span> (err &lt; 0)
</span></span><span style=display:flex><span>		<span style=color:#00f>goto</span> errout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#00f>if</span> (tb[IFLA_IFNAME])
</span></span><span style=display:flex><span>		nla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);
</span></span><span style=display:flex><span>	<span style=color:#00f>else</span>
</span></span><span style=display:flex><span>		ifname[0] = <span style=color:#a31515>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#00f>if</span> (!net_eq(tgt_net, dev_net(dev))) {
</span></span><span style=display:flex><span>		<span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *pat = ifname[0] ? ifname : NULL;
</span></span><span style=display:flex><span>		<span style=color:#2b91af>int</span> new_ifindex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		new_ifindex = nla_get_s32_default(tb[IFLA_NEW_IFINDEX], 0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		err = __dev_change_net_namespace(dev, tgt_net, pat, new_ifindex);
</span></span></code></pre></div><p>These attributes may include:</p><ul><li><code>IFLA_NET_NS_PID</code>: Target namespace identified by process ID.</li><li><code>IFLA_NET_NS_FD</code>: Target namespace identified by file descriptor.</li><li><strong><code>IFLA_IFNAME</code></strong>: Specifies the desired name of the interface in the target namespace.</li></ul><p>The core function responsible for moving interfaces, <code>__dev_change_net_namespace</code>, directly interacts with <code>IFLA_IFNAME</code>.
As documented in the kernel API documentation: <a href=https://www.kernel.org/doc/html/latest/networking/kapi.html#c.__dev_change_net_namespace>__dev_change_net_namespace</a>,
this function shuts down a device interface and moves it to a new network namespace.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#2b91af>int</span> __dev_change_net_namespace(<span style=color:#00f>struct</span> net_device *dev, <span style=color:#00f>struct</span> net *net,
</span></span><span style=display:flex><span>                                   <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *pat, <span style=color:#2b91af>int</span> new_ifindex);
</span></span></code></pre></div><p>Let&rsquo;s see some examples, using <code>strace</code> we can see the netlink messages:</p><p>We can indicates just the destination namespace, <code>ip link</code> gets the interface index by the name and sends a RTM_NEWLINK
message with the IFLA_NET_NS_FD attribute for setting the network namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green># ip netns add ns1</span>
</span></span><span style=display:flex><span><span style=color:green># ip netns exec ns1 ip link</span>
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span><span style=color:green># ip link add dummy0 type dummy</span>
</span></span><span style=display:flex><span><span style=color:green># strace -e trace=network ip link set dummy0 netns ns1 2&gt;&amp;1 | grep RTM_NEWLINK | grep sendmsg</span>
</span></span><span style=display:flex><span>sendmsg(3, {msg_name={sa_family=AF_NETLINK, nl_pid=0, nl_groups=00000000}, msg_namelen=12, msg_iov=[{iov_base=[{nlmsg_len=40, nlmsg_type=RTM_NEWLINK, nlmsg_flags=NLM_F_REQUEST|NLM_F_ACK, nlmsg_seq=1742478199, nlmsg_pid=0}, {ifi_family=AF_UNSPEC, ifi_type=ARPHRD_NETROM, ifi_index=if_nametoindex(<span style=color:#a31515>&#34;dummy0&#34;</span>), ifi_flags=0, ifi_change=0}, [{nla_len=8, nla_type=IFLA_NET_NS_FD}, 4]], iov_len=40}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 40
</span></span><span style=display:flex><span><span style=color:green># ip netns exec ns1 ip link</span>
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>24: dummy0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/ether 4e:3d:fe:03:2c:c8 brd ff:ff:ff:ff:ff:ff
</span></span></code></pre></div><p>If we try to move a device with a name that already exist in the namespace then we&rsquo;ll have an error</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green># ip link set dummy0 netns ns1</span>
</span></span><span style=display:flex><span>RTNETLINK answers: File exists
</span></span></code></pre></div><p>Network interface names have a long history of issues, more on <a href=https://wiki.debian.org/NetworkInterfaceNames>https://wiki.debian.org/NetworkInterfaceNames</a>.</p><p>And since names MUST be unique per network namespace, we can do a &ldquo;change network namespace and rename&rdquo; operation at the same time.
In this case, we are going to rename <code>dummy0</code> to <code>othername</code>, and see how we have the <code>IFLA_IFNAME</code> attribute now.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>~# strace -e trace=network ip link set dummy0 netns ns1 name othername 2&gt;&amp;1 | grep RTM_NEWLINK | grep sendmsg
</span></span><span style=display:flex><span>sendmsg(3, {msg_name={sa_family=AF_NETLINK, nl_pid=0, nl_groups=00000000}, msg_namelen=12, msg_iov=[{iov_base=[{nlmsg_len=56, nlmsg_type=RTM_NEWLINK, nlmsg_flags=NLM_F_REQUEST|NLM_F_ACK, nlmsg_seq=1742479211, nlmsg_pid=0}, {ifi_family=AF_UNSPEC, ifi_type=ARPHRD_NETROM, ifi_index=if_nametoindex(<span style=color:#a31515>&#34;dummy0&#34;</span>), ifi_flags=0, ifi_change=0}, [[{nla_len=8, nla_type=IFLA_NET_NS_FD}, 4], [{nla_len=14, nla_type=IFLA_IFNAME}, <span style=color:#a31515>&#34;othername&#34;</span>]]], iov_len=56}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 56
</span></span><span style=display:flex><span>jkenj1:~# ip netns exec ns1 ip link
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>24: dummy0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/ether 4e:3d:fe:03:2c:c8 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>27: othername: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/ether b6:a9:c0:0f:41:39 brd ff:ff:ff:ff:ff:ff
</span></span></code></pre></div><p>However, there is also another nice property if we don&rsquo;t mind about the destination name and just the prefix,
and is that we can use template by appending <code>%d</code> to the IFLA_IFNAME attribute, and the interface name will be add an
unique suffix to avoid to break:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green># ip link add dummy0 type dummy</span>
</span></span><span style=display:flex><span><span style=color:green># ip link set dummy0 netns ns1 name othername</span>
</span></span><span style=display:flex><span>RTNETLINK answers: File exists
</span></span><span style=display:flex><span><span style=color:green># ip link set dummy0 netns ns1 name othername%d</span>
</span></span><span style=display:flex><span>jkenj1:~# ip netns exec ns1 ip link
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>24: dummy0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/ether 4e:3d:fe:03:2c:c8 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>27: othername: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/ether b6:a9:c0:0f:41:39 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>28: othername1: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
</span></span><span style=display:flex><span>    link/ether 16:96:7c:ab:33:bb brd ff:ff:ff:ff:ff:ff
</span></span></code></pre></div><h2 id=namespace-deletion-and-cleanup>Namespace Deletion and Cleanup</h2><p>We saw how to move interfaces between network namespaces, that applies in both direction, I can move the interface
from the root namespace to the network namespace and viceversa, but what happens when the network namespace is deleted.</p><p>Checking at <a href=https://github.com/torvalds/linux/blob/a7f2e10ecd8f18b83951b0bab47ddaf48f93bf47/net/core/dev.c#L12370>https://github.com/torvalds/linux/blob/a7f2e10ecd8f18b83951b0bab47ddaf48f93bf47/net/core/dev.c#L12370</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#00f>static</span> <span style=color:#2b91af>void</span> __net_exit default_device_exit_net(<span style=color:#00f>struct</span> net *net)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#00f>struct</span> netdev_name_node *name_node, *tmp;
</span></span><span style=display:flex><span>	<span style=color:#00f>struct</span> net_device *dev, *aux;
</span></span><span style=display:flex><span>	<span style=color:green>/*
</span></span></span><span style=display:flex><span><span style=color:green>	 * Push all migratable network devices back to the
</span></span></span><span style=display:flex><span><span style=color:green>	 * initial network namespace
</span></span></span><span style=display:flex><span><span style=color:green>	 */</span>
</span></span><span style=display:flex><span>	ASSERT_RTNL();
</span></span><span style=display:flex><span>	for_each_netdev_safe(net, dev, aux) {
</span></span><span style=display:flex><span>		<span style=color:#2b91af>int</span> err;
</span></span><span style=display:flex><span>		<span style=color:#2b91af>char</span> fb_name[IFNAMSIZ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:green>/* Ignore unmoveable devices (i.e. loopback) */</span>
</span></span><span style=display:flex><span>		<span style=color:#00f>if</span> (dev-&gt;netns_local)
</span></span><span style=display:flex><span>			<span style=color:#00f>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:green>/* Leave virtual devices for the generic cleanup */</span>
</span></span><span style=display:flex><span>		<span style=color:#00f>if</span> (dev-&gt;rtnl_link_ops &amp;&amp; !dev-&gt;rtnl_link_ops-&gt;netns_refund)
</span></span><span style=display:flex><span>			<span style=color:#00f>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:green>/* Push remaining network devices to init_net */</span>
</span></span><span style=display:flex><span>		snprintf(fb_name, IFNAMSIZ, <span style=color:#a31515>&#34;dev%d&#34;</span>, dev-&gt;ifindex);
</span></span><span style=display:flex><span>		<span style=color:#00f>if</span> (netdev_name_in_use(&amp;init_net, fb_name))
</span></span><span style=display:flex><span>			snprintf(fb_name, IFNAMSIZ, <span style=color:#a31515>&#34;dev%%d&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		netdev_for_each_altname_safe(dev, name_node, tmp)
</span></span><span style=display:flex><span>			<span style=color:#00f>if</span> (netdev_name_in_use(&amp;init_net, name_node-&gt;name))
</span></span><span style=display:flex><span>				__netdev_name_node_alt_destroy(name_node);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		err = dev_change_net_namespace(dev, &amp;init_net, fb_name);
</span></span><span style=display:flex><span>		<span style=color:#00f>if</span> (err) {
</span></span><span style=display:flex><span>			pr_emerg(<span style=color:#a31515>&#34;%s: failed to move %s to init_net: %d</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>,
</span></span><span style=display:flex><span>				 __func__, dev-&gt;name, err);
</span></span><span style=display:flex><span>			BUG();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>we can see that the logic is as follow:</p><ul><li>unmoveable device and virtual devices will not be moved back</li><li>remaining network devices (physical interfaces, &mldr;) will be moved back:<ul><li>with the existing name if possible, or with the <code>dev%d</code> or <code>dev%%d</code> template name</li></ul></li></ul><p>If you wonder about virtual vs physical, you can just check the sysfs filesystem</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>~# ls -al /sys/class/net/
</span></span><span style=display:flex><span>total 0
</span></span><span style=display:flex><span>drwxr-xr-x  2 root root    0 Mar 20 07:26 .
</span></span><span style=display:flex><span>drwxr-xr-x 71 root root    0 Mar 20 07:26 ..
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 adp0 -&gt; ../../devices/virtual/net/adp0
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 adp1 -&gt; ../../devices/virtual/net/adp1
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 adp2 -&gt; ../../devices/virtual/net/adp2
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 adp3 -&gt; ../../devices/virtual/net/adp3
</span></span><span style=display:flex><span>-rw-r--r--  1 root root 4096 Mar 20 07:26 bonding_masters
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 dcn1 -&gt; ../../devices/pci0000:57/0000:57:00.0/0000:58:00.0/net/dcn1
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 dcn2 -&gt; ../../devices/pci0000:97/0000:97:00.0/0000:98:00.0/net/dcn2
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 dev0 -&gt; ../../devices/pci0000:d7/0000:d7:00.0/0000:d8:00.0/net/dev0
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 dev7 -&gt; ../../devices/virtual/net/dev7
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 eth0 -&gt; ../../devices/virtual/net/eth0
</span></span><span style=display:flex><span>lrwxrwxrwx  1 root root    0 Mar 20 07:26 eth1 -&gt; ../../devices/pci0000:37/0000:37:00.0/0000:38:00.0/net/eth1
</span></span></code></pre></div><p>As you can see in the list above, I just moved one physical interface to a network namespace and created a dummy device with the same name with the same name, once I deleted the namespace with the physical interface it came back to the root namespcae as <code>dev0</code></p><h2 id=alternative-names>Alternative Names</h2><p>Linux <a href=https://patchwork.ozlabs.org/project/netdev/cover/20190930094820.11281-1-jiri@resnulli.us/#2269624>added in 2019 the capability to set alternative names on network interfaces</a>, mainly to avoid the
current lenght limitation</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span> ip link property add dev DEVICE [ altname NAME .. ]
</span></span><span style=display:flex><span> ip link property del dev DEVICE [ altname NAME .. ]
</span></span></code></pre></div><p>However, this will not help to solve the name conflict problem, just the opposite, since it increases the risk of collision</p><pre tabindex=0><code># ip netns exec ns1 ip link
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: dummy0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 4a:02:e1:87:96:07 brd ff:ff:ff:ff:ff:ff
# ip link property add dev dummy1 altname dummy0
# ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
5: dummy1: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether 6e:08:0a:b4:15:11 brd ff:ff:ff:ff:ff:ff
    altname dummy0
# ip link set dummy0 netns ns1
RTNETLINK answers: File exists
</code></pre><h2 id=interfaces-naming-with-systemd>Interfaces naming with systemd</h2><p>Linux network interface naming has evolved to provide more predictable and consistent names, moving away from the older, less reliable &ldquo;ethX&rdquo; scheme. Systemd&rsquo;s systemd.net-naming-scheme plays a crucial role in this.</p><p>The core idea is to assign names based on hardware and firmware information, making them independent of the order in which devices are detected. This prevents interface names from changing unexpectedly, especially after hardware changes or kernel updates. The scheme prioritizes different naming types, falling back to less specific methods when necessary.</p><p>systemd-udevd assigns predictable network interface names based on hardware info (firmware, PCI, MAC) via rules in /etc/udev/rules.d/. It listens for kernel uevents and names interfaces like ens1 or wlp2s0. systemd-networkd then uses these consistent names to apply network configurations from /etc/systemd/network/, ensuring stable network settings across reboots.</p><p>We can use <code>udevadm monitor</code> to monitor:</p><ul><li>UDEV: the event which udev sends out after rule processing</li><li>KERNEL: the kernel uevent</li></ul><h3 id=virtual-interfaces>Virtual interfaces</h3><p>When we create a virtual interface</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green># ip link add dummy3 type dummy</span>
</span></span></code></pre></div><p>we get following events:</p><pre tabindex=0><code>KERNEL[160479.602268] add      /devices/virtual/net/dummy3 (net)
KERNEL[160479.602296] add      /devices/virtual/net/dummy3/queues/rx-0 (queues)
KERNEL[160479.602305] add      /devices/virtual/net/dummy3/queues/tx-0 (queues)
UDEV  [160479.602891] add      /devices/virtual/net/dummy3 (net)
UDEV  [160479.603089] add      /devices/virtual/net/dummy3/queues/rx-0 (queues)
UDEV  [160479.603254] add      /devices/virtual/net/dummy3/queues/tx-0 (queues)
</code></pre><p>If we move the virtual interface to a namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green># ip netns add ns1</span>
</span></span><span style=display:flex><span><span style=color:green># ip link set dummy3 netns ns1</span>
</span></span></code></pre></div><p>we get</p><pre tabindex=0><code>KERNEL[160552.155591] remove   /devices/virtual/net/dummy3 (net)
UDEV  [160552.156038] remove   /devices/virtual/net/dummy3 (net)
</code></pre><p>If we move it back:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green>#ip netns exec ns1 ip link set dummy3 netns  root</span>
</span></span></code></pre></div><p>we get</p><pre tabindex=0><code>KERNEL[160597.604155] add      /devices/virtual/net/dummy3 (net)
KERNEL[160597.604200] move     /devices/virtual/net/dummy3 (net)
UDEV  [160597.605054] add      /devices/virtual/net/dummy3 (net)
UDEV  [160597.605453] move     /devices/virtual/net/dummy3 (net)
</code></pre><p>However, since it is a virtual interface, when we delete the namespace it just disappears.</p><h3 id=physical-interfaces>Physical interfaces</h3><p>Physical interfaces are similar, the only difference is that when the namespace is deleted,
they come back to the root namespace &mldr; and if the name collide, they are renamed.</p><p>In this example I move the <code>dev0</code> interface to a namespace.
Then create a virtual interface <code>dev0</code> in the root namespace.
And then delete the namespace.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green># ip netns add ns1</span>
</span></span><span style=display:flex><span><span style=color:green># ip link set dev0 netns ns1</span>
</span></span><span style=display:flex><span><span style=color:green># ip link add dev0 type dummy</span>
</span></span><span style=display:flex><span><span style=color:green># ip netns del ns1</span>
</span></span></code></pre></div><pre tabindex=0><code>KERNEL[159662.875424] remove   /devices/pci0000:d7/0000:d7:00.0/0000:d8:00.0/net/dev0 (net)
UDEV  [159662.875849] remove   /devices/pci0000:d7/0000:d7:00.0/0000:d8:00.0/net/dev0 (net)


KERNEL[159679.855918] add      /devices/virtual/net/dev0 (net)
KERNEL[159679.855938] add      /devices/virtual/net/dev0/queues/rx-0 (queues)
KERNEL[159679.855946] add      /devices/virtual/net/dev0/queues/tx-0 (queues)
UDEV  [159679.856473] add      /devices/virtual/net/dev0 (net)
UDEV  [159679.856673] add      /devices/virtual/net/dev0/queues/rx-0 (queues)
UDEV  [159679.856844] add      /devices/virtual/net/dev0/queues/tx-0 (queues)

KERNEL[159695.029543] add      /devices/pci0000:d7/0000:d7:00.0/0000:d8:00.0/net/dev0 (net)
KERNEL[159695.029565] move     /devices/pci0000:d7/0000:d7:00.0/0000:d8:00.0/net/dev1 (net)
UDEV  [159695.030036] add      /devices/pci0000:d7/0000:d7:00.0/0000:d8:00.0/net/dev0 (net)
UDEV  [159695.030665] move     /devices/pci0000:d7/0000:d7:00.0/0000:d8:00.0/net/dev1 (net)
</code></pre></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="SIG Network mailing list" aria-label="SIG Network mailing list"><a target=_blank rel=noopener href=https://groups.google.com/forum/#!forum/kubernetes-sig-network aria-label="SIG Network mailing list"><i class="fa fa-envelope"></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/dranet aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Slack aria-label=Slack><a target=_blank rel=noopener href=https://kubernetes.slack.com/messages/sig-network aria-label=Slack><i class="fab fa-slack"></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2024&ndash;2025
<span class=td-footer__authors>Google LLC | <a href=https://creativecommons.org/licenses/by/4.0>CC BY 4.0</a> |</span></span><span class=td-footer__all_rights_reserved>All Rights Reserved</span><span class=ms-2><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.d9615597e83c4193e3ab1e6816bad5c8741894e92c5b5c17a8d1d4be6d9af8a2.js integrity="sha256-2WFVl+g8QZPjqx5oFrrVyHQYlOksW1wXqNHUvm2a+KI=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>